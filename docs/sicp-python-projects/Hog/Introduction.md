# 引言

:::info
译者：[Spike014](https://github.com/spike014)

来源：[Hog - Introduction](https://inst.eecs.berkeley.edu/~cs61a/fa20/proj/hog/#introduction)

对应：Project 01 - Introduction
:::

在这个项目，你将为骰子游戏**贪吃猪**（`Hog`） 开发一个模拟器和多种规则。你会需要同时使用到[控制语句](../../sicp-python/ch1/1-5.md)和[高阶函数](../../sicp-python/ch1/1-6.md)，就像正文的 `1.2` 到 `1.6` 节所讲述的那样。

## 规则

在贪吃猪中，两个玩家轮流尝试成为第一个以至少 `100` 分结束回合的玩家。在每一回合，当前玩家选择一定数量的骰子进行掷骰，最多 `10` 个。该玩家的本回合得分是这些骰子结果的总和。然而，一个掷太多骰子的玩家有以下风险：

- **狼吞虎咽（Pig out）**。如果任何一个骰子结果为 `1`，则当前玩家在该回合的得分为 `1`。

    <details>
        <summary>示例</summary>

    - 示例 1：当前玩家掷骰子 `7` 个，其中 `5` 个是 `1`。他们在本回合得 `1` 分。

    - 示例 2：当前玩家掷出 `4` 个骰子，全部为 `3`。由于没有触发狼吞虎咽规则，他们在本回合得了 `12` 分。

    </details>

在正常的贪吃猪游戏中，这些是全部的规则了。为了给游戏增添趣味，我们将会包括一些特殊规则：

- **无偿培根（Free Bacon）**。选择掷 `0` 骰子的玩家得分 `k+3` 分，其中 `k` 是小数点后 `pi` 的 `n` 位数字， `n` 是对手的总分。作为特例，如果对手的分数是 `n = 0` ，那么 `k = 3` （`pi`小数点前的数字）。

    <details>
        <summary>示例</summary>

    - 示例 1：对手得分为 `0`，当前玩家掷骰子为 `0`。当前玩家将获得 `3 + 3 = 6` 分。
    - 示例 2：对手得分为 `1`，当前玩家掷骰子为 `0`。当前玩家将获得 `1 + 3 = 4` 分。
    - 示例 3：对手得分为 `2`，当前玩家掷骰子为 `0`。当前玩家将获得 `4 + 3 = 7` 分。
    - 示例 4：对手得分为 `42`，当前玩家掷骰子为 `0`。当前玩家将获得 `9 + 3 = 12` 分。

    </details>

- **猪之看齐（Swine Align）**。回合的分数添加到当前玩家的分数后，如果两个玩家的分数均为正数，并且当前玩家分数的最大公约数（`GCD`）和对手的分数至少为 `10`，则再进行一次回合。

    <details>
        <summary>示例</summary>

    - 示例 1：在第一个玩家的回合结束时，玩家的分数为`8`和`36`。两个分数的最大公约数是`4`，所以第一个玩家不会因为猪之看齐规则再进行另一回合。
    - 示例 2：在第一个玩家的回合结束时，玩家的分数为`20`和`30`。两个分数的最大公约数是`10`，所以第一个玩家进行一个额外的回合。
    - 示例 3：在第一个玩家的回合结束时，玩家的得分分别为`24`和`36`。分数的最大公约数是`12`，所以第一个玩家需要一个额外的回合。第一个玩家掷出`12`，现在比分是`36`和`36`。分数的最大公约数是`36`，所以第一个玩家再进行另一回合。
    - 示例 4：在第一个玩家的回合结束时，玩家的分数为`15`和`0`。猪之看齐规则只适用于当两个玩家的分数都是正数（不是`0`），所以第一个玩家不会由于猪之看齐规则再进行另一回合。

    </details>

- **猪之突破（Pig Pass）**。在回合的分数被添加到当前玩家的分数之后，如果当前玩家的分数低于对手的分数并且它们之间的差小于`3`，则当前玩家进行另一回合。

    <details>
        <summary>示例</summary>

    - 示例 1：在第一个玩家的回合结束时，对手得分为`10`，当前玩家得分为`11`。由于`11 > 10`，当前玩家不会由于猪之突破规则而再进行另一回合。
    - 示例 2：在第一个玩家的回合结束时，对手得分为`10`，当前玩家得分为`7`。因为 `10 - 7 = 3 >= 3` ，当前玩家不会因猪之突破规则而再进行另一回合。
    - 示例 3：在第一个玩家的回合结束时，对手得分为`30`，当前玩家得分为`28`。因为`30 - 28 = 2 < 3`，当前玩家将进行另一回合。
    - 示例 4：在第一个玩家的回合结束时，对手得分为`30`，当前玩家得分为`28`。与示例 3一样，当前玩家进行另一回合。如果当前玩家掷出`1`，现在得分为`29`，再次触发猪之突破规则，当前玩家还另外再进行一回合。

    </details>

## 最终成品

伯克利教职员工的项目解答可以在 [hog.cs61a.org](https://hog.cs61a.org/) 上玩
-- 快去试玩下它吧！当你完成这个项目，你自己已经实现这个游戏最重要的部分。

## 下载初始文件

要开始的话，请将项目所有的代码作为[zip归档文件](https://inst.eecs.berkeley.edu/~cs61a/fa20/proj/hog/hog.zip)下载。下面是你将在归档文件中看到的所有文件的列表。但是你只需对 `hog.py` 进行更改。

- `hog.py` ：贪吃猪的初始实现
- `dice.py` ：掷骰子的函数
- `hog_gui.py` ：贪吃猪的图形用户界面（`GUI`）
- `ucb.py` ：`CS61A`的公用函数
- `ok` ：`CS61A` 自动评分器
- `tests` ： `ok` 使用的测试目录
- `gui_files` ：`Web GUI`使用的各种内容的目录

## 组织工作（Logistics）

对于要求完成的功能，我们可能会提供一些初始代码。如果你不想使用这些代码，请随意删除它并重新开始。如果觉得合适，你也可以添加新的函数。

但是，请不要修改任何其他功能。这样做可能会导致你的代码无法通过自动评分器测试。另外，请不要更改任何函数签名（名称、参数顺序或参数数量）。

在整个项目中，你应该测试代码的正确性。经常进行测试是一种很好的做法，这样就可以很容易地分离出一些问题。但是，你不应该太频繁地测试，而应该给自己时间去思考问题。

我们提供了一个名为 `ok` 的自动评分器来帮助你测试代码和跟踪你的进度。

`ok` 的主要目的是测试你的实现。

```shell
python3 ok --local
```

> 译者注：自学的同学不需要在使用 ok 的时候对自己的进度上传到伯克利进行备份自己的进度和提交作业，而且也没有伯克利的账号，因此每次使用 ok 的时候都建议带上参数 `--local`。

使用此选项，将不会向伯克利发送任何信息。如果要以交互方式测试代码，可以运行

```shell
 python3 ok -q [问题编号] -i 
```

填写对应的问题编号（例如 `01` ）。这将运行该问题的测试，直到第一个失败的测试，然后交互式地给你一个机会来测试编写的函数。

你还可以在 `OK` 中使用调试打印功能，方法是写这样一行代码

```py
print("DEBUG:", x) 
```

这将在你的终端中产生一个输出，而不会导致 `OK` 测试因额外的输出而失败。

## 图形用户界面

一个图形用户界面（简称`GUI`）已经提供给你。现在，它还不能正常运行，因为你还没有实现游戏逻辑。一旦你完成了 `play` 功能，你将可以玩到完全互动版本的贪吃猪！

完成后，你可以从终端运行`GUI`：

```shell
python3 hog_gui.py
```

`GUI`是一个[托管在 `Github` 上的开源项目](https://github.com/Cal-CS-61A-Staff/hog-gui)。
